页面从请求到渲染出来是一个复杂的过程，涉及网络通信、浏览器解析、渲染引擎工作等多个环节。以下是详细的步骤解析，分为 网络请求阶段 和 浏览器渲染阶段 两大部分：

一、网络请求阶段
1. 输入 URL 并按下回车
DNS 查询：浏览器将域名解析为 IP 地址（可能使用本地缓存、浏览器缓存、操作系统缓存或 DNS 服务器）。
建立 TCP 连接：通过三次握手与服务器建立 TCP 连接（HTTP/1.1 默认长连接，HTTP/2/3 支持多路复用）。
TLS 握手（HTTPS）：如果是 HTTPS 请求，需进行 TLS 握手（交换密钥、验证证书）。
2. 发送 HTTP 请求
浏览器构造 HTTP 请求报文（包含请求行、请求头、请求体），发送到服务器。
关键请求头：
Host：目标域名。
User-Agent：浏览器标识。
Accept：可接收的内容类型（如 text/html）。
Cookie：携带用户身份信息（如有）。
3. 服务器处理请求
路由匹配：服务器根据 URL 和请求方法（GET/POST）找到对应的处理逻辑。
数据库查询（可选）：如需动态数据，服务器从数据库读取数据。
生成响应：服务器构造 HTTP 响应报文（状态码、响应头、响应体）。
关键响应头：
Content-Type：资源类型（如 text/html; charset=utf-8）。
Cache-Control：缓存策略（如 max-age=3600）。
Set-Cookie：设置 Cookie（如用户会话标识）。
4. 返回响应并断开连接
服务器发送响应后，根据连接类型（HTTP/1.1 长连接或 HTTP/2 多路复用）决定是否断开 TCP 连接。
浏览器接收响应数据，开始解析。
二、浏览器渲染阶段
1. 解析 HTML（构建 DOM 树）
字节流 → 字符流：浏览器将接收到的字节流按编码（如 UTF-8）转换为字符流。
词法分析：将字符流分解为标记（Tokens，如 <html>、<div>）。
语法分析：根据 HTML 规则将标记转换为节点（Nodes），构建 DOM 树（Document Object Model）。
示例：
html
<html>
  <body>
    <h1>Hello</h1>
  </body>
</html>
→ DOM 树结构：
Document
  └── html
      └── body
          └── h1: "Hello"
2. 解析 CSS（构建 CSSOM 树）
浏览器解析 <style> 标签或外部 CSS 文件，生成 CSSOM 树（CSS Object Model）。
关键步骤：
解析 CSS 规则（选择器、属性）。
计算每个节点的最终样式（继承、层叠、优先级）。
示例：
css
h1 { color: red; }
→ CSSOM 树片段：
h1 {
  color: red;
}
3. 解析 JavaScript（可选）
阻塞渲染：默认情况下，<script> 会阻塞 DOM 构建（除非标记 async 或 defer）。
执行 JavaScript：
脚本可能修改 DOM（如 document.body.innerHTML = "..."）。
脚本可能修改 CSSOM（如动态添加样式）。
触发重排（Reflow）或重绘（Repaint）。
4. 构建渲染树（Render Tree）
合并 DOM 和 CSSOM：浏览器遍历 DOM 树，结合 CSSOM 计算每个节点的可见样式，生成 渲染树（仅包含需渲染的节点）。
隐藏节点：display: none 的节点不会出现在渲染树中。
示例：
html
<h1 style="color: red;">Hello</h1>
<p style="display: none;">Hidden</p>
→ 渲染树仅包含 h1 节点。
5. 布局（Layout / Reflow）
计算几何信息：浏览器根据渲染树确定每个节点的位置、大小（如宽度、高度、边距）。
触发条件：
首次渲染。
窗口大小变化。
DOM 或 CSS 修改（如添加元素、修改 width）。
6. 绘制（Paint）
生成图层：浏览器将渲染树拆分为多个图层（如文本、背景、边框）。
光栅化（Rasterization）：将图层转换为像素矩阵（GPU 加速可提升性能）。
合成（Compositing）：合并所有图层，生成最终图像并显示在屏幕上。
7. 交互与重绘（Repaint）
用户交互：如点击、滚动触发 JavaScript 事件。
重绘：仅修改颜色、背景等不影响布局的属性时，跳过布局阶段，直接重绘。
重排：修改布局相关属性（如 width、position）时，需重新计算布局。
三、关键优化点
1. 减少网络请求
合并文件：CSS/JS 合并减少请求次数。
使用 CDN：加速静态资源加载。
启用 HTTP/2：多路复用减少连接开销。
2. 优化渲染性能
避免阻塞渲染：
将 <script> 放在 <body> 末尾或使用 async/defer。
避免内联大尺寸 CSS。
减少重排/重绘：
使用 transform 和 opacity 替代 width/top（触发 GPU 加速）。
批量修改 DOM（如 documentFragment）。
利用缓存：
设置合理的 Cache-Control 和 ETag。
使用 Service Worker 缓存资源。
3. 现代框架优化
Vue/React：
虚拟 DOM 减少真实 DOM 操作。
异步渲染（如 Vue 的 nextTick、React 的 Fiber 架构）。
静态生成：
使用 Next.js/Nuxt.js 预渲染页面，减少客户端计算。
四、完整流程图示
用户输入 URL → DNS 查询 → TCP 连接 → TLS 握手（HTTPS） → HTTP 请求 → 
服务器处理 → 返回响应 → 
浏览器解析 HTML/CSS/JS → 构建 DOM/CSSOM → 合并为渲染树 → 布局 → 绘制 → 显示
总结
页面渲染是浏览器、网络、开发者代码共同协作的结果。理解其全流程有助于：

优化加载速度（减少请求、压缩资源）。
提升渲染性能（避免重排、使用 GPU 加速）。
调试问题（如通过 Chrome DevTools 分析网络和渲染瓶颈）。
